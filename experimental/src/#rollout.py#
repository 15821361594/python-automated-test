import sut as SUT
import random
import time
import sys
import traceback
import argparse
import os
from collections import namedtuple

def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument('-d', '--depth', type=int, default=-1,
                        help='Maximum search depth (-1=infinite default).')
    parser.add_argument('-t', '--timeout', type=int, default=3600,
                        help='Timeout in seconds (3600 default).')
    parser.add_argument('-r', '--random', action="store_true",
                        help='Randomize transition order')
    parser.add_argument('-s', '--seed', type=int, default=None,
                        help='Random seed (default = None).')
    parsed_args = parser.parse_args(sys.argv[1:])
    return (parsed_args, parser)

def make_config(pargs, parser):
    """
    Process the raw arguments, returning a namedtuple object holding the
    entire configuration, if everything parses correctly.
    """
    pdict = pargs.__dict__
    # create a namedtuple object for fast attribute lookup
    key_list = pdict.keys()
    arg_list = [pdict[k] for k in key_list]
    Config = namedtuple('Config', key_list)
    nt_config = Config(*arg_list)
    return nt_config   
    
parsed_args, parser = parse_args()
config = make_config(parsed_args, parser)
print('Running policy rollout using config={}'.format(config))

if config.seed != None:
    random.seed(config.seed)

def replay(path):
    elapsed = time.time() - start
    covertool.clearCoverage()
    test.restart()
    for s in path:
        try:
            s[2]()
        except:
            pass
        elapsed = time.time() - start
        if (elapsed > start):
            print "TIMEOUT"
            break

def sample(act):
    reward = 0.0
    elapsed = time.time() - start
    if (elapsed > start):
        print "TIMEOUT"
        return
    if not act[1]():
        return reward
    try:
        act[2]()
    except:
        pass
    for s in xrange(0,min(TEST_LENGTH-len(path)-1,SAMPLE_DEPTH)):
        op = random.choice(test.enabled())
        try:
            op[2]()
        except:
            pass
        elapsed = time.time() - start
        if (elapsed > start):
            print "TIMEOUT"
            break
    if (elapsed > start):
        print "TIMEOUT"
        return
    for l in covertool.getCoverage():
        reward += goals[l] # * covertool.getCoverage()[l] if you want to reward multi-cov vs. diversity
    return reward

timeout = int(sys.argv[1])

start = time.time()
elapsed = time.time()-start

goals = {}
for l in open("domsim_INST.py"):
    if "covertool.cover" in l:
        ls = l.split('"')
        goals[ls[1]] = 1.0

action = {}
for act in test.actions:
    action[act[0]] = act

covertool.clearCoverage()

paths = []

nowCovered = []
lastCovered = []

ntests = 0
while elapsed < timeout:
    ntests += 1
    path = []
    
    while (len(path) < TEST_LENGTH) and (elapsed < timeout):
        bestReward = 0.0
        actReward = {}
        timesSampled = {}
        actEstimate = {}
        nsamples = 0
        random.shuffle(test.actions)
        # nothing depends on the order, and this avoids bias of early choices being likely to have max reward
        replay(path)
        nowCovered = covertool.getCoverage()
        for nc in nowCovered:
            if nc not in lastCovered:
                print "COVERED:",nc
                lastCovered.append(nc)
        print len(path),len(test.enabled())
        bestAct = random.choice(test.enabled())
        for act in test.enabled():
            actReward[act[0]] = 0.0
            timesSampled[act[0]] = 0
            actEstimate[act[0]] = 0.0
            for t in xrange(0,INIT_SAMPLES):
                nsamples += 1
                actReward[act[0]] += sample(act)
                replay(path)
                timesSampled[act[0]] += 1
                actEstimate[act[0]] = actReward[act[0]]/timesSampled[act[0]]
            if actEstimate[act[0]] > bestReward:
                bestAct = act[0]
                bestReward = (actEstimate[act[0]])
            elapsed = time.time() - start
            if (elapsed > timeout):
                print "TIMEOUT"
                break
        if (elapsed > timeout):
            print "TIMEOUT"
            break
        while (nsamples < TOTAL_SAMPLES):
            if random.random() >= EXPLORE_PROB:
                act = random.choice(test.enabled()) # explore
            else:
                act = action[bestAct] # exploit
            nsamples += 1
            actReward[act[0]] += sample(act)
            replay(path)
            timesSampled[act[0]] += 1
            actEstimate[act[0]] = actReward[act[0]]/timesSampled[act[0]]
            sortedEstimates = sorted(actEstimate.iteritems(), key = lambda(x): x[1], reverse = True)
            if (sortedEstimates[0][0] != bestAct):
                bestAct = sortedEstimates[0][0]
                bestReward = sortedEstimates[0][1]
            elapsed = time.time() - start
            if (elapsed > timeout):
                print "TIMEOUT"
                break
        if (elapsed > timeout):
            print "TIMEOUT"
            break           
        path.append(action[bestAct])
        print len(path),action[bestAct][0]
        elapsed = time.time() - start
    paths.append(list(path))
    if (elapsed > timeout):
        print "TIMEOUT"
        break    
    for c in covertool.getTotalCoverage():
        goals[c] = math.pow(DECAY, covertool.getTotalCoverage()[c])
    elapsed = time.time() - start
    if (elapsed > timeout):
        print "TIMEOUT"
        break
    
print ntests, "EXECUTED"

n = 0
for p in paths:
    n += 1
    print "PATH",n, map(lambda x:x[0], p)

cover = covertool.getTotalCoverage()

for c in cover:
    print c, cover[c]

print len(cover)
