\section{Introduction}

It has long been understood that effective automated testing requires
test case reduction \cite{DD,MinUnit,ICSEDiff} to produce test cases
that remove irrelevant operations.  In fact, test case reduction is
now standard practice in industral testing tools such as Mozilla's
{\tt jsfunfuzz}.  However, simply reducing the length of a test case
does not produce true semantic minimality.  There may be many
1-minimal test cases that present different variations of a single
fault.  In many cases, reading more than one of these test cases
provides no useful additional information on the cause of failure.

Consider the three test cases shown in Figure \ref{threetests}.  These
test cases are obviously very similar, and in fact all lead to a
violation of the property that an AVL tree must always be nearly
balanced, due to a missing call to {\tt rebalance} in {\tt delete} in
a Python implementation of AVL trees.  However, the test cases are
syntactically very different, and a testing system that collects
failing test cases will produce three tests for a user to examine.
While there are methods for attempting to determine which test cases
represent distinct faults \cite{PLDI13}, the ideal solution is
arguably to rewrite all three of these test cases into a single,
normal form that preserves the structure of the failure while removing
such accidental aspects of each test case as the particular integer
values and variables used, and the ordering of assignments and
insertions.

Figure \ref{normalgen} shows the result of applying our \emph{test case
  normalization} method to these three tests, and then applying our
\emph{test case generalization} approach to the normalized test case.
First, we note that all three test cases normalize to the same test
case.  This test case, in addition to the 10 steps required to produce
the failure, includes comments indicating what about the test case can
be changed while still failing in the same way.  For instance, the
value 1 assigned to {\tt int0} in step 0 is not essential.  It could
be changed to any value in the range 5-20 (the total set of values
allowed by the test generator) without changing the final result.  The
same is true of the assignment of 3 to {\tt int1}.  Similarly, the
ordering of many steps in the test case is not important.  Finally,
step 9 is annotated to show that instead of using the existing value
of {\tt int1} (4), a fresh assignment could be inserted before the
{\tt delete} call, setting {\tt
  int1} to 3 instead.  These possible
changes are not meant to be combined --- the annotation claims only
that changing these aspects of the test case one at a time will
preserve failure.

Many test cases that expose the same fault will normalize to the same
test case --- many, but not all.  Running 100,000 tests (of length
100) on the faulty AVL tree produces 860 failing test cases with no
duplicates.  Normalizing these reduces the number of distinct failing
test cases to only 22.  Of course, ideally \emph{all} failures due to the same fault
would normalize to a single, representative test case, but we can only
aim to approximate such a canonical form for faults.  Figure
\ref{diffnorm} shows an example test case that normalizes differently,
and its normalized form (we omit the generalization, which is not
interestingly different than that for the first normalized test case).

\begin{figure}
{\scriptsize
{\bf Test case \#1}
\begin{code}
avl0 = avl.AVLTree() 
int0 = 4 
int2 = 13 
int3 = 7 
avl0.insert(int2) 
avl0.insert(int3) 
int1 = 15 
avl0.insert(int1) 
avl0.insert(int0) 
avl0.delete(int2)
\end{code}
{\bf Test case \#2}
\begin{code}
int0 = 14 
avl0 = avl.AVLTree() 
int2 = 13 
int1 = 15 
avl0.insert(int1) 
int1 = 11 
avl0.insert(int2) 
avl0.insert(int0) 
avl0.insert(int1) 
avl0.delete(int0) 
\end{code}
{\bf Test case \#3}
\begin{code}
avl1 = avl.AVLTree() 
int3 = 18 
avl1.insert(int3) 
int0 = 5 
int3 = 12 
avl1.insert(int0) 
int0 = 15 
avl1.insert(int0) 
avl1.insert(int3) 
int1 = 15 
avl1.delete(int1) 
\end{code}
}
\caption {Three randomly generated test cases for the same fault.}
\label{threetests}
\end{figure}

\begin{figure}
{\scriptsize
\begin{code}
\#[
int0 = 1                       \# STEP 0
\#  or int0 = 5 
\#   - int0 = 20 
\#  swaps with step 4
int1 = 3                       \# STEP 1
\#  or int1 = 5 
\#   - int1 = 20 
\#  swaps with step 6
avl0 = avl.AVLTree()           \# STEP 2
\#] (steps in [] can be in any order)
avl0.insert(int0)              \# STEP 3
\#[
int0 = 2                       \# STEP 4
\#  swaps with step 0
avl0.insert(int1)              \# STEP 5
\#] (steps in [] can be in any order)
int1 = 4                       \# STEP 6
\#  or int1 = 5 
\#   - int1 = 20 
\#  swaps with step 1
avl0.insert(int1)              \# STEP 7
avl0.insert(int0)              \# STEP 8
avl0.delete(int1)              \# STEP 9
\#  or (
\#      int1 = 3  ;
\#      avl0.delete(int1) 
\#     )
\end{code}
}
\caption{Normalization and generalization for all three test cases.
  Lines beginning with \# are comments in Python, here used to
annotate the test case.}
\label{normalgen}
\end{figure}

\begin{figure}
{\scriptsize
{\bf Test case \#4:}
\begin{code}
int0 = 10 
int2 = 7 
avl1 = avl.AVLTree() 
avl1.insert(int2) 
avl1.insert(int0) 
int1 = 1 
int3 = 1 
avl1.insert(int3) 
int3 = 15 
avl1.insert(int3) 
avl1.delete(int1) 
\end{code}
{\bf Normalized:}
\begin{code}
int0 = 1
int1 = 2
avl0 = avl.AVLTree()
avl0.insert(int0) 
avl0.insert(int1) 
int1 = 3  
avl0.insert(int1) 
int1 = 4  
avl0.insert(int1)  
avl0.delete(int0) 
\end{code}
}
\caption{A differently normalized test case for the same fault}
\label{diffnorm}
\end{figure}