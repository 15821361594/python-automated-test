\section{A Brief Primer on TSTL}

\begin{figure}
{\scriptsize
\begin{code}
@import avl
\vspace{0.05in}
pool: <int> 4 CONST
pool: <avl> 3
\vspace{0.05in}
property: <avl>.check\_balanced()
\vspace{0.05in}
<int> := <[1..20]>
<avl> := avl.AVLTree()
\vspace{0.05in}
<avl>.insert(<int>)
<avl>.delete(<int>)
<avl>.find(<int>)
<avl>.inorder()
\end{code}
}
\caption{Part of a TSTL definition of AVL tree tests.}
\label{fig:example}
\end{figure}

\comment{
\begin{figure}
{\scriptsize
\begin{code}
avl1 = avl.AVLTree()  
int3 = 10  
int1 = 11  
avl1.insert(int1) 
int1 = 1  
avl1.insert(int3) 
avl1.insert(int1) 
int3 = 9  
avl1.insert(int3) 
int2 = 11  
avl1.delete(int2) 
\end{code}
}
\caption{An example TSTL-produced test}
\label{fig:avlrun}
\end{figure}
}

TSTL \cite{NFM15,ISSTA15,TSTL} is a language for defining the structure of
test cases (usually API-call sequences, but also grammar-based tests using
string construction), and a set of tools for use in generating,
manipulating, and understanding those test cases.  Figure
\ref{fig:example} shows a simplified portion of a TSTL definition of
tests of an AVL tree class, in the latest syntax for TSTL (which
differs slightly from that in the cited papers introducing TSTL).
TSTL provides numerous features not shown in this small example,
including automatic differential testing, complex logging, support for
complex guards, and use of pre- and post- values.  Given a harness
like the one in Figure \ref{fig:example}, TSTL compiles it into a
class file defining an interface for testing that provides features
such as querying the set of available testing actions, restarting a
test, replaying a test, collecting code coverage data, and so forth.
The TSTL release \cite{tstl} provides testing tools that use the
interface for test generation and debugging.

The key point for our purposes is merely that a TSTL test harness
defines a set of \emph{pools} that hold values produced and used
during testing \cite{AndrewsTR} (a common approach to defining
API-testing sequences) and a set of actions that are possible during
testing, typically API calls and assignments to pool values.  In this
example, there are two pools, one named {\tt int} and one named {\tt
  avl}.  There are four instances of the {\tt int} pool, which means
that a test in progress can store up to 4 {\tt int}s at one time (in
variables named {\tt int0}, {\tt int1}, {\tt int2}, and {\tt int3}), and three
instances of the {\tt avl} pool.  The actions defined here are setting
the value of an {\tt int} pool to any integer in the range 1-20
inclusive, setting the value of an {\tt avl} pool to a newly
constructed AVL tree, and calling an AVL tree's {\tt insert}, {\tt
  delete}, {\tt find} and {\tt inorder} methods.  Figure
\ref{threetests} in the introduction shows three
valid test cases produced by running a random test generator on
the TSTL-compiled interface produced by this definition.  TSTL handles
ensuring that tests are well-formed: for example, no pool instance
(such as {\tt avl1} can appear in an action until it has been assigned
a value), and no pool instance that has been assigned a value can be
assigned a different value until it has been used in an action, to
avoid degenerate sequences such as {\tt int3 = 10} followed by {\tt
  int3 = 4}.  Each action in a test case is called a ``step'' --- the
first step of the first test case in Figure \ref{threetests} is storing a new AVL tree in {\tt
  avl0}, for example.

